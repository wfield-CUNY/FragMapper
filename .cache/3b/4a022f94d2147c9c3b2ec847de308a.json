{"id":"node_modules/cesium/Source/Shaders/ModelExperimental/MaterialStageFS.js","dependencies":[{"name":"D:\\Users\\Will\\Documents\\CUNY\\Research\\FragMapper\\package.json","includedInParent":true,"mtime":1640105766009},{"name":"D:\\Users\\Will\\Documents\\CUNY\\Research\\FragMapper\\node_modules\\cesium\\package.json","includedInParent":true,"mtime":1640105765416}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n//This file is automatically rebuilt by the Cesium build process.\nvar _default = \"// If the style color is white, it implies the feature has not been styled.\\n\\\nbool isDefaultStyleColor(vec3 color)\\n\\\n{\\n\\\n    return all(greaterThan(color, vec3(1.0 - czm_epsilon3)));\\n\\\n}\\n\\\n\\n\\\nvec3 blend(vec3 sourceColor, vec3 styleColor, float styleColorBlend)\\n\\\n{\\n\\\n    vec3 blendColor = mix(sourceColor, styleColor, styleColorBlend);\\n\\\n    vec3 color = isDefaultStyleColor(styleColor.rgb) ? sourceColor : blendColor;\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\nvec3 SRGBtoLINEAR3(vec3 srgbIn) \\n\\\n{\\n\\\n    return pow(srgbIn, vec3(2.2));\\n\\\n}\\n\\\n\\n\\\nvec4 SRGBtoLINEAR4(vec4 srgbIn) \\n\\\n{\\n\\\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\\n\\\n    return vec4(linearOut, srgbIn.a);\\n\\\n}\\n\\\n\\n\\\nvec2 computeTextureTransform(vec2 texCoord, mat3 textureTransform)\\n\\\n{\\n\\\n    return vec2(textureTransform * vec3(texCoord, 1.0));\\n\\\n}\\n\\\n\\n\\\n#ifdef HAS_NORMALS\\n\\\nvec3 computeNormal(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    // Geometry normal. This is already normalized \\n\\\n    vec3 ng = attributes.normalEC;\\n\\\n\\n\\\n    vec3 normal = ng;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n    vec2 normalTexCoords = TEXCOORD_NORMAL;\\n\\\n        #ifdef HAS_NORMAL_TEXTURE_TRANSFORM\\n\\\n        normalTexCoords = computeTextureTransform(normalTexCoords, u_normalTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        // If HAS_BITANGENTS is set, then HAS_TANGENTS is also set\\n\\\n        #ifdef HAS_BITANGENTS\\n\\\n        vec3 t = attributes.tangentEC;\\n\\\n        vec3 b = attributes.bitangentEC;\\n\\\n        mat3 tbn = mat3(t, b, ng);\\n\\\n        vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normal = normalize(tbn * (2.0 * n - 1.0));\\n\\\n        #elif defined(GL_OES_standard_derivatives)\\n\\\n        // Compute tangents\\n\\\n        vec3 positionEC = attributes.positionEC;\\n\\\n        vec3 pos_dx = dFdx(positionEC);\\n\\\n        vec3 pos_dy = dFdy(positionEC);\\n\\\n        vec3 tex_dx = dFdx(vec3(normalTexCoords,0.0));\\n\\\n        vec3 tex_dy = dFdy(vec3(normalTexCoords,0.0));\\n\\\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n\\\n        t = normalize(t - ng * dot(ng, t));\\n\\\n        vec3 b = normalize(cross(ng, t));\\n\\\n        mat3 tbn = mat3(t, b, ng);\\n\\\n        vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normal = normalize(tbn * (2.0 * n - 1.0));\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    return normal;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvoid materialStage(inout czm_modelMaterial material, ProcessedAttributes attributes, Feature feature)\\n\\\n{\\n\\\n\\n\\\n    #ifdef HAS_NORMALS\\n\\\n    material.normalEC = computeNormal(attributes);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = vec4(1.0);\\n\\\n    // Regardless of whether we use PBR, set a base color\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE\\n\\\n    vec2 baseColorTexCoords = TEXCOORD_BASE_COLOR;\\n\\\n\\n\\\n        #ifdef HAS_BASE_COLOR_TEXTURE_TRANSFORM\\n\\\n        baseColorTexCoords = computeTextureTransform(baseColorTexCoords, u_baseColorTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n    baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, baseColorTexCoords));\\n\\\n\\n\\\n        #ifdef HAS_BASE_COLOR_FACTOR\\n\\\n        baseColorWithAlpha *= u_baseColorFactor;\\n\\\n        #endif\\n\\\n    #elif defined(HAS_BASE_COLOR_FACTOR)\\n\\\n    baseColorWithAlpha = u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_COLOR_0\\n\\\n    baseColorWithAlpha *= attributes.color_0;\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = baseColorWithAlpha.rgb;\\n\\\n    material.alpha = baseColorWithAlpha.a;\\n\\\n\\n\\\n    #ifdef USE_CPU_STYLING\\n\\\n    material.diffuse = blend(material.diffuse, feature.color.rgb, model_colorBlend);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_OCCLUSION_TEXTURE\\n\\\n    vec2 occlusionTexCoords = TEXCOORD_OCCLUSION;\\n\\\n        #ifdef HAS_OCCLUSION_TEXTURE_TRANSFORM\\n\\\n        occlusionTexCoords = computeTextureTransform(occlusionTexCoords, u_occlusionTextureTransform);\\n\\\n        #endif\\n\\\n    material.occlusion = texture2D(u_occlusionTexture, occlusionTexCoords).r;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE\\n\\\n    vec2 emissiveTexCoords = TEXCOORD_EMISSIVE;\\n\\\n        #ifdef HAS_EMISSIVE_TEXTURE_TRANSFORM\\n\\\n        emissiveTexCoords = computeTextureTransform(emissiveTexCoords, u_emissiveTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, emissiveTexCoords).rgb);\\n\\\n        #ifdef HAS_EMISSIVE_FACTOR\\n\\\n        emissive *= u_emissiveFactor;\\n\\\n        #endif\\n\\\n    material.emissive = emissive;\\n\\\n    #elif defined(HAS_EMISSIVE_FACTOR)\\n\\\n    material.emissive = u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\n        #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE\\n\\\n        vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS;\\n\\\n          #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM\\n\\\n          specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform);\\n\\\n          #endif\\n\\\n\\n\\\n        vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, specularGlossinessTexCoords));\\n\\\n        vec3 specular = specularGlossiness.rgb;\\n\\\n        float glossiness = specularGlossiness.a;\\n\\\n            #ifdef HAS_SPECULAR_FACTOR\\n\\\n            specular *= u_specularFactor;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            glossiness *= u_glossinessFactor;\\n\\\n            #endif\\n\\\n        #else\\n\\\n            #ifdef HAS_SPECULAR_FACTOR\\n\\\n            vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\\n\\\n            #else\\n\\\n            vec3 specular = vec3(1.0);\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\\\n            #else\\n\\\n            float glossiness = 1.0;\\n\\\n            #endif\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_DIFFUSE_TEXTURE\\n\\\n        vec2 diffuseTexCoords = TEXCOORD_DIFFUSE;\\n\\\n            #ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM\\n\\\n            diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform);\\n\\\n            #endif\\n\\\n\\n\\\n        vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, diffuseTexCoords));\\n\\\n            #ifdef HAS_DIFFUSE_FACTOR\\n\\\n            diffuse *= u_diffuseFactor;\\n\\\n            #endif\\n\\\n        #elif defined(HAS_DIFFUSE_FACTOR)\\n\\\n        vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\\\n        #else\\n\\\n        vec4 diffuse = vec4(1.0);\\n\\\n        #endif\\n\\\n    czm_pbrParameters parameters = czm_pbrSpecularGlossinessMaterial(\\n\\\n      diffuse.rgb,\\n\\\n      specular,\\n\\\n      glossiness\\n\\\n    );\\n\\\n    material.diffuse = parameters.diffuseColor;\\n\\\n    // the specular glossiness extension's alpha overrides anything set\\n\\\n    // by the base material.\\n\\\n    material.alpha = diffuse.a;\\n\\\n    material.specular = parameters.f0;\\n\\\n    material.roughness = parameters.roughness;\\n\\\n    #elif defined(LIGHTING_PBR)\\n\\\n        #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE\\n\\\n        vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS;\\n\\\n            #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform);\\n\\\n            #endif\\n\\\n\\n\\\n        vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb;\\n\\\n        float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\\\n        float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\\n\\\n            #ifdef HAS_METALLIC_FACTOR\\n\\\n            metalness *= u_metallicFactor;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            roughness *= u_roughnessFactor;\\n\\\n            #endif\\n\\\n        #else\\n\\\n            #ifdef HAS_METALLIC_FACTOR\\n\\\n            float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\\\n            #else\\n\\\n            float metalness = 1.0;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\\n\\\n            #else\\n\\\n            float roughness = 1.0;\\n\\\n            #endif\\n\\\n        #endif\\n\\\n    czm_pbrParameters parameters = czm_pbrMetallicRoughnessMaterial(\\n\\\n      material.diffuse,\\n\\\n      metalness,\\n\\\n      roughness\\n\\\n    );\\n\\\n    material.diffuse = parameters.diffuseColor;\\n\\\n    material.specular = parameters.f0;\\n\\\n    material.roughness = parameters.roughness;\\n\\\n    #endif\\n\\\n}\\n\\\n\";\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"node_modules/cesium/Source/Shaders/ModelExperimental/MaterialStageFS.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":15},"source":"node_modules/cesium/Source/Shaders/ModelExperimental/MaterialStageFS.js","original":{"line":2,"column":15}}],"sources":{"node_modules/cesium/Source/Shaders/ModelExperimental/MaterialStageFS.js":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// If the style color is white, it implies the feature has not been styled.\\n\\\nbool isDefaultStyleColor(vec3 color)\\n\\\n{\\n\\\n    return all(greaterThan(color, vec3(1.0 - czm_epsilon3)));\\n\\\n}\\n\\\n\\n\\\nvec3 blend(vec3 sourceColor, vec3 styleColor, float styleColorBlend)\\n\\\n{\\n\\\n    vec3 blendColor = mix(sourceColor, styleColor, styleColorBlend);\\n\\\n    vec3 color = isDefaultStyleColor(styleColor.rgb) ? sourceColor : blendColor;\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\nvec3 SRGBtoLINEAR3(vec3 srgbIn) \\n\\\n{\\n\\\n    return pow(srgbIn, vec3(2.2));\\n\\\n}\\n\\\n\\n\\\nvec4 SRGBtoLINEAR4(vec4 srgbIn) \\n\\\n{\\n\\\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\\n\\\n    return vec4(linearOut, srgbIn.a);\\n\\\n}\\n\\\n\\n\\\nvec2 computeTextureTransform(vec2 texCoord, mat3 textureTransform)\\n\\\n{\\n\\\n    return vec2(textureTransform * vec3(texCoord, 1.0));\\n\\\n}\\n\\\n\\n\\\n#ifdef HAS_NORMALS\\n\\\nvec3 computeNormal(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    // Geometry normal. This is already normalized \\n\\\n    vec3 ng = attributes.normalEC;\\n\\\n\\n\\\n    vec3 normal = ng;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n    vec2 normalTexCoords = TEXCOORD_NORMAL;\\n\\\n        #ifdef HAS_NORMAL_TEXTURE_TRANSFORM\\n\\\n        normalTexCoords = computeTextureTransform(normalTexCoords, u_normalTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        // If HAS_BITANGENTS is set, then HAS_TANGENTS is also set\\n\\\n        #ifdef HAS_BITANGENTS\\n\\\n        vec3 t = attributes.tangentEC;\\n\\\n        vec3 b = attributes.bitangentEC;\\n\\\n        mat3 tbn = mat3(t, b, ng);\\n\\\n        vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normal = normalize(tbn * (2.0 * n - 1.0));\\n\\\n        #elif defined(GL_OES_standard_derivatives)\\n\\\n        // Compute tangents\\n\\\n        vec3 positionEC = attributes.positionEC;\\n\\\n        vec3 pos_dx = dFdx(positionEC);\\n\\\n        vec3 pos_dy = dFdy(positionEC);\\n\\\n        vec3 tex_dx = dFdx(vec3(normalTexCoords,0.0));\\n\\\n        vec3 tex_dy = dFdy(vec3(normalTexCoords,0.0));\\n\\\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n\\\n        t = normalize(t - ng * dot(ng, t));\\n\\\n        vec3 b = normalize(cross(ng, t));\\n\\\n        mat3 tbn = mat3(t, b, ng);\\n\\\n        vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normal = normalize(tbn * (2.0 * n - 1.0));\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    return normal;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvoid materialStage(inout czm_modelMaterial material, ProcessedAttributes attributes, Feature feature)\\n\\\n{\\n\\\n\\n\\\n    #ifdef HAS_NORMALS\\n\\\n    material.normalEC = computeNormal(attributes);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = vec4(1.0);\\n\\\n    // Regardless of whether we use PBR, set a base color\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE\\n\\\n    vec2 baseColorTexCoords = TEXCOORD_BASE_COLOR;\\n\\\n\\n\\\n        #ifdef HAS_BASE_COLOR_TEXTURE_TRANSFORM\\n\\\n        baseColorTexCoords = computeTextureTransform(baseColorTexCoords, u_baseColorTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n    baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, baseColorTexCoords));\\n\\\n\\n\\\n        #ifdef HAS_BASE_COLOR_FACTOR\\n\\\n        baseColorWithAlpha *= u_baseColorFactor;\\n\\\n        #endif\\n\\\n    #elif defined(HAS_BASE_COLOR_FACTOR)\\n\\\n    baseColorWithAlpha = u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_COLOR_0\\n\\\n    baseColorWithAlpha *= attributes.color_0;\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = baseColorWithAlpha.rgb;\\n\\\n    material.alpha = baseColorWithAlpha.a;\\n\\\n\\n\\\n    #ifdef USE_CPU_STYLING\\n\\\n    material.diffuse = blend(material.diffuse, feature.color.rgb, model_colorBlend);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_OCCLUSION_TEXTURE\\n\\\n    vec2 occlusionTexCoords = TEXCOORD_OCCLUSION;\\n\\\n        #ifdef HAS_OCCLUSION_TEXTURE_TRANSFORM\\n\\\n        occlusionTexCoords = computeTextureTransform(occlusionTexCoords, u_occlusionTextureTransform);\\n\\\n        #endif\\n\\\n    material.occlusion = texture2D(u_occlusionTexture, occlusionTexCoords).r;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE\\n\\\n    vec2 emissiveTexCoords = TEXCOORD_EMISSIVE;\\n\\\n        #ifdef HAS_EMISSIVE_TEXTURE_TRANSFORM\\n\\\n        emissiveTexCoords = computeTextureTransform(emissiveTexCoords, u_emissiveTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, emissiveTexCoords).rgb);\\n\\\n        #ifdef HAS_EMISSIVE_FACTOR\\n\\\n        emissive *= u_emissiveFactor;\\n\\\n        #endif\\n\\\n    material.emissive = emissive;\\n\\\n    #elif defined(HAS_EMISSIVE_FACTOR)\\n\\\n    material.emissive = u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\n        #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE\\n\\\n        vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS;\\n\\\n          #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM\\n\\\n          specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform);\\n\\\n          #endif\\n\\\n\\n\\\n        vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, specularGlossinessTexCoords));\\n\\\n        vec3 specular = specularGlossiness.rgb;\\n\\\n        float glossiness = specularGlossiness.a;\\n\\\n            #ifdef HAS_SPECULAR_FACTOR\\n\\\n            specular *= u_specularFactor;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            glossiness *= u_glossinessFactor;\\n\\\n            #endif\\n\\\n        #else\\n\\\n            #ifdef HAS_SPECULAR_FACTOR\\n\\\n            vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\\n\\\n            #else\\n\\\n            vec3 specular = vec3(1.0);\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\\\n            #else\\n\\\n            float glossiness = 1.0;\\n\\\n            #endif\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_DIFFUSE_TEXTURE\\n\\\n        vec2 diffuseTexCoords = TEXCOORD_DIFFUSE;\\n\\\n            #ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM\\n\\\n            diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform);\\n\\\n            #endif\\n\\\n\\n\\\n        vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, diffuseTexCoords));\\n\\\n            #ifdef HAS_DIFFUSE_FACTOR\\n\\\n            diffuse *= u_diffuseFactor;\\n\\\n            #endif\\n\\\n        #elif defined(HAS_DIFFUSE_FACTOR)\\n\\\n        vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\\\n        #else\\n\\\n        vec4 diffuse = vec4(1.0);\\n\\\n        #endif\\n\\\n    czm_pbrParameters parameters = czm_pbrSpecularGlossinessMaterial(\\n\\\n      diffuse.rgb,\\n\\\n      specular,\\n\\\n      glossiness\\n\\\n    );\\n\\\n    material.diffuse = parameters.diffuseColor;\\n\\\n    // the specular glossiness extension's alpha overrides anything set\\n\\\n    // by the base material.\\n\\\n    material.alpha = diffuse.a;\\n\\\n    material.specular = parameters.f0;\\n\\\n    material.roughness = parameters.roughness;\\n\\\n    #elif defined(LIGHTING_PBR)\\n\\\n        #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE\\n\\\n        vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS;\\n\\\n            #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform);\\n\\\n            #endif\\n\\\n\\n\\\n        vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb;\\n\\\n        float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\\\n        float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\\n\\\n            #ifdef HAS_METALLIC_FACTOR\\n\\\n            metalness *= u_metallicFactor;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            roughness *= u_roughnessFactor;\\n\\\n            #endif\\n\\\n        #else\\n\\\n            #ifdef HAS_METALLIC_FACTOR\\n\\\n            float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\\\n            #else\\n\\\n            float metalness = 1.0;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\\n\\\n            #else\\n\\\n            float roughness = 1.0;\\n\\\n            #endif\\n\\\n        #endif\\n\\\n    czm_pbrParameters parameters = czm_pbrMetallicRoughnessMaterial(\\n\\\n      material.diffuse,\\n\\\n      metalness,\\n\\\n      roughness\\n\\\n    );\\n\\\n    material.diffuse = parameters.diffuseColor;\\n\\\n    material.specular = parameters.f0;\\n\\\n    material.roughness = parameters.roughness;\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"},"lineCount":null}},"error":null,"hash":"c90830987656e3b86cc634c220acafae","cacheData":{"env":{}}}