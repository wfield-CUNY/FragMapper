{"id":"node_modules/cesium/Source/Shaders/GlobeFS.js","dependencies":[{"name":"D:\\Users\\Will\\Documents\\CUNY\\Research\\FragMapper\\package.json","includedInParent":true,"mtime":1640105766009},{"name":"D:\\Users\\Will\\Documents\\CUNY\\Research\\FragMapper\\node_modules\\cesium\\package.json","includedInParent":true,"mtime":1640105765416}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n//This file is automatically rebuilt by the Cesium build process.\nvar _default = \"uniform vec4 u_initialColor;\\n\\\n\\n\\\n#if TEXTURE_UNITS > 0\\n\\\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\\n\\\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\\n\\\nuniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];\\n\\\n\\n\\\n#ifdef APPLY_ALPHA\\n\\\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_DAY_NIGHT_ALPHA\\n\\\nuniform float u_dayTextureNightAlpha[TEXTURE_UNITS];\\n\\\nuniform float u_dayTextureDayAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\nuniform float u_dayTextureSplit[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\nuniform float u_dayTextureHue[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_GAMMA\\n\\\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_IMAGERY_CUTOUT\\n\\\nuniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\nuniform vec4 u_colorsToAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\nuniform sampler2D u_waterMask;\\n\\\nuniform vec4 u_waterMaskTranslationAndScale;\\n\\\nuniform float u_zoomedOutOceanSpecularIntensity;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\nuniform sampler2D u_oceanNormalMap;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\nuniform vec2 u_lightingFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\nuniform vec4 u_cartographicLimitRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nuniform vec2 u_nightFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\nuniform highp sampler2D u_clippingPlanes;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\nuniform vec4 u_clippingPlanesEdgeStyle;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\nuniform float u_minimumBrightness;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef COLOR_CORRECT\\n\\\nuniform vec3 u_hsbShift; // Hue, saturation, brightness\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\nuniform vec4 u_fillHighlightColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nuniform vec4 u_frontFaceAlphaByDistance;\\n\\\nuniform vec4 u_backFaceAlphaByDistance;\\n\\\nuniform vec4 u_translucencyRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\nuniform vec4 u_undergroundColor;\\n\\\nuniform vec4 u_undergroundColorAlphaByDistance;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec3 v_positionMC;\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_textureCoordinates;\\n\\\nvarying vec3 v_normalMC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\nvarying float v_height;\\n\\\nvarying float v_slope;\\n\\\nvarying float v_aspect;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nvarying float v_distance;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\nvarying vec3 v_fogRayleighColor;\\n\\\nvarying vec3 v_fogMieColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvarying vec3 v_rayleighColor;\\n\\\nvarying vec3 v_mieColor;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nfloat interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)\\n\\\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\\n\\\n{\\n\\\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nbool inTranslucencyRectangle()\\n\\\n{\\n\\\n    return\\n\\\n        v_textureCoordinates.x > u_translucencyRectangle.x &&\\n\\\n        v_textureCoordinates.x < u_translucencyRectangle.z &&\\n\\\n        v_textureCoordinates.y > u_translucencyRectangle.y &&\\n\\\n        v_textureCoordinates.y < u_translucencyRectangle.w;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvec4 sampleAndBlend(\\n\\\n    vec4 previousColor,\\n\\\n    sampler2D textureToSample,\\n\\\n    vec2 tileTextureCoordinates,\\n\\\n    vec4 textureCoordinateRectangle,\\n\\\n    vec4 textureCoordinateTranslationAndScale,\\n\\\n    float textureAlpha,\\n\\\n    float textureNightAlpha,\\n\\\n    float textureDayAlpha,\\n\\\n    float textureBrightness,\\n\\\n    float textureContrast,\\n\\\n    float textureHue,\\n\\\n    float textureSaturation,\\n\\\n    float textureOneOverGamma,\\n\\\n    float split,\\n\\\n    vec4 colorToAlpha,\\n\\\n    float nightBlend)\\n\\\n{\\n\\\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\\n\\\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\\n\\\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\\n\\\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\\n\\\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\\n\\\n    // In other words, the alpha is zero if the fragment is outside the rectangle\\n\\\n    // covered by this texture.  Would an actual 'if' yield better performance?\\n\\\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);\\n\\\n#endif\\n\\\n\\n\\\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\\n\\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\n\\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\n\\\n    vec4 value = texture2D(textureToSample, textureCoordinates);\\n\\\n    vec3 color = value.rgb;\\n\\\n    float alpha = value.a;\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\n    vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);\\n\\\n    colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b);\\n\\\n    alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);\\n\\\n#endif\\n\\\n\\n\\\n#if !defined(APPLY_GAMMA)\\n\\\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\\n\\\n    color = tempColor.rgb;\\n\\\n    alpha = tempColor.a;\\n\\\n#else\\n\\\n    color = pow(color, vec3(textureOneOverGamma));\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\n    float splitPosition = czm_imagerySplitPosition;\\n\\\n    // Split to the left\\n\\\n    if (split < 0.0 && gl_FragCoord.x > splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n    // Split to the right\\n\\\n    else if (split > 0.0 && gl_FragCoord.x < splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\n    color = mix(vec3(0.0), color, textureBrightness);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\n    color = mix(vec3(0.5), color, textureContrast);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\n    color = czm_hue(color, textureHue);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\n    color = czm_saturation(color, textureSaturation);\\n\\\n#endif\\n\\\n\\n\\\n    float sourceAlpha = alpha * textureAlpha;\\n\\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\n\\\n    outAlpha += sign(outAlpha) - 1.0;\\n\\\n\\n\\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\n\\\n\\n\\\n    // When rendering imagery for a tile in multiple passes,\\n\\\n    // some GPU/WebGL implementation combinations will not blend fragments in\\n\\\n    // additional passes correctly if their computation includes an unmasked\\n\\\n    // divide-by-zero operation,\\n\\\n    // even if it's not in the output or if the output has alpha zero.\\n\\\n    //\\n\\\n    // For example, without sanitization for outAlpha,\\n\\\n    // this renders without artifacts:\\n\\\n    //   if (outAlpha == 0.0) { outColor = vec3(0.0); }\\n\\\n    //\\n\\\n    // but using czm_branchFreeTernary will cause portions of the tile that are\\n\\\n    // alpha-zero in the additional pass to render as black instead of blending\\n\\\n    // with the previous pass:\\n\\\n    //   outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor);\\n\\\n    //\\n\\\n    // So instead, sanitize against divide-by-zero,\\n\\\n    // store this state on the sign of outAlpha, and correct on return.\\n\\\n\\n\\\n    return vec4(outColor, max(outAlpha, 0.0));\\n\\\n}\\n\\\n\\n\\\nvec3 colorCorrect(vec3 rgb) {\\n\\\n#ifdef COLOR_CORRECT\\n\\\n    // Convert rgb color to hsb\\n\\\n    vec3 hsb = czm_RGBToHSB(rgb);\\n\\\n    // Perform hsb shift\\n\\\n    hsb.x += u_hsbShift.x; // hue\\n\\\n    hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0); // saturation\\n\\\n    hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0; // brightness\\n\\\n    // Convert shifted hsb back to rgb\\n\\\n    rgb = czm_HSBToRGB(hsb);\\n\\\n#endif\\n\\\n    return rgb;\\n\\\n}\\n\\\n\\n\\\nvec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist);\\n\\\n#endif\\n\\\n\\n\\\nconst float fExposure = 2.0;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\n    if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||\\n\\\n        v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)\\n\\\n        {\\n\\\n            discard;\\n\\\n        }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)\\n\\\n    vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));   // normalized surface normal in model coordinates\\n\\\n    vec3 normalEC = czm_normal3D * normalMC;                                         // normalized surface normal in eye coordiantes\\n\\\n#endif\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);\\n\\\n#else\\n\\\n    float nightBlend = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\\n\\\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\\n\\\n    // fragments on the edges of tiles even though the vertex shader is outputting\\n\\\n    // coordinates strictly in the 0-1 range.\\n\\\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);\\n\\\n\\n\\\n#ifdef SHOW_TILE_BOUNDARIES\\n\\\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\\n\\\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\\n\\\n    {\\n\\\n        color = vec4(1.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\n    float cameraDist;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;\\n\\\n    }\\n\\\n    else if (czm_sceneMode == czm_sceneModeColumbusView)\\n\\\n    {\\n\\\n        cameraDist = -czm_view[3].z;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        cameraDist = length(czm_view[3]);\\n\\\n    }\\n\\\n    float fadeOutDist = u_lightingFadeDistance.x;\\n\\\n    float fadeInDist = u_lightingFadeDistance.y;\\n\\\n    if (czm_sceneMode != czm_sceneMode3D) {\\n\\\n        vec3 radii = czm_ellipsoidRadii;\\n\\\n        float maxRadii = max(radii.x, max(radii.y, radii.z));\\n\\\n        fadeOutDist -= maxRadii;\\n\\\n        fadeInDist -= maxRadii;\\n\\\n    }\\n\\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n#else\\n\\\n    float fade = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\\n\\\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\\n\\\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;\\n\\\n    waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;\\n\\\n\\n\\\n    float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;\\n\\\n\\n\\\n    if (mask > 0.0)\\n\\\n    {\\n\\\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\\n\\\n\\n\\\n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);\\n\\\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);\\n\\\n\\n\\\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\\n\\\n\\n\\\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.st = v_textureCoordinates.st;\\n\\\n    materialInput.normalEC = normalize(v_normalEC);\\n\\\n    materialInput.positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));     \\n\\\n    materialInput.slope = v_slope;\\n\\\n    materialInput.height = v_height;\\n\\\n    materialInput.aspect = v_aspect;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    vec4 materialColor = vec4(material.diffuse, material.alpha);\\n\\\n    color = alphaBlend(materialColor, color);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * 0.9 + 0.3, 0.0, 1.0);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#elif defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\n\\\n    diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#else\\n\\\n    vec4 finalColor = color;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\\n\\\n\\n\\\n    if (clipDistance < clippingPlanesEdgeWidth)\\n\\\n    {\\n\\\n        finalColor = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\n    finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\n    vec3 fogColor = colorCorrect(v_fogMieColor) + finalColor.rgb * colorCorrect(v_fogRayleighColor);\\n\\\n#ifndef HDR\\n\\\n    fogColor = vec3(1.0) - exp(-fExposure * fogColor);\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)\\n\\\n    vec3 atmosphereLightDirection = czm_sunDirectionWC;\\n\\\n#else\\n\\\n    vec3 atmosphereLightDirection = czm_lightDirectionWC;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef FOG\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n    float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);\\n\\\n    fogColor *= darken;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    const float modifier = 0.15;\\n\\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor, modifier), finalColor.a);\\n\\\n#else\\n\\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor), finalColor.a);\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\n    if (!czm_backFacing())\\n\\\n    {\\n\\\n        vec3 groundAtmosphereColor = computeGroundAtmosphereColor(fogColor, finalColor, atmosphereLightDirection, cameraDist);\\n\\\n        finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\n    if (czm_backFacing())\\n\\\n    {\\n\\\n        float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);\\n\\\n        float distance = max(v_distance - distanceFromEllipsoid, 0.0);\\n\\\n        float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);\\n\\\n        vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);\\n\\\n        finalColor = alphaBlend(undergroundColor, finalColor);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\n    if (inTranslucencyRectangle())\\n\\\n    {\\n\\\n      vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;\\n\\\n      finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragColor = finalColor;\\n\\\n}\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist)\\n\\\n{\\n\\\n#if defined(PER_FRAGMENT_GROUND_ATMOSPHERE) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))\\n\\\n    float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);\\n\\\n    vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);\\n\\\n    xy *= czm_viewport.zw * mpp * 0.5;\\n\\\n\\n\\\n    vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x));\\n\\\n    czm_ray ray = czm_ray(vec3(0.0), direction);\\n\\\n\\n\\\n    vec3 ellipsoid_center = czm_view[3].xyz;\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\\n\\\n\\n\\\n    vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);\\n\\\n    ellipsoidPosition = (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;\\n\\\n    AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(ellipsoidPosition, true, atmosphereLightDirection);\\n\\\n\\n\\\n    vec3 groundAtmosphereColor = colorCorrect(atmosColor.mie) + finalColor.rgb * colorCorrect(atmosColor.rayleigh);\\n\\\n#ifndef HDR\\n\\\n    groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\n\\\n#endif\\n\\\n\\n\\\n    float fadeInDist = u_nightFadeDistance.x;\\n\\\n    float fadeOutDist = u_nightFadeDistance.y;\\n\\\n\\n\\\n    float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    // Some tweaking to make HDR look better\\n\\\n    sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\n\\\n#endif\\n\\\n\\n\\\n    groundAtmosphereColor = mix(groundAtmosphereColor, fogColor, sunlitAtmosphereIntensity);\\n\\\n#else\\n\\\n    vec3 groundAtmosphereColor = fogColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    // Some tweaking to make HDR look better\\n\\\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\n\\\n#endif\\n\\\n\\n\\\n    return groundAtmosphereColor;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\\n\\\nfloat waveFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n    return pow(1.0 - y, 5.0);\\n\\\n}\\n\\\n\\n\\\nfloat linearFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Based on water rendering by Jonas Wagner:\\n\\\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\\n\\\n\\n\\\n// low altitude wave settings\\n\\\nconst float oceanFrequencyLowAltitude = 825000.0;\\n\\\nconst float oceanAnimationSpeedLowAltitude = 0.004;\\n\\\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\\n\\\nconst float oceanSpecularIntensity = 0.5;\\n\\\n\\n\\\n// high altitude wave settings\\n\\\nconst float oceanFrequencyHighAltitude = 125000.0;\\n\\\nconst float oceanAnimationSpeedHighAltitude = 0.008;\\n\\\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\\n\\\n\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -positionEyeCoordinates;\\n\\\n    float positionToEyeECLength = length(positionToEyeEC);\\n\\\n\\n\\\n    // The double normalize below works around a bug in Firefox on Android devices.\\n\\\n    vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));\\n\\\n\\n\\\n    // Fade out the waves as the camera moves far from the surface.\\n\\\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // high altitude waves\\n\\\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\\n\\\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\\n\\\n\\n\\\n    // low altitude waves\\n\\\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\\n\\\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\\n\\\n\\n\\\n    // blend the 2 wave layers based on distance to surface\\n\\\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\\n\\\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\\n\\\n    vec3 normalTangentSpace =\\n\\\n        (highAltitudeFade * normalTangentSpaceHighAltitude) +\\n\\\n        (lowAltitudeFade * normalTangentSpaceLowAltitude);\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n\\n\\\n    // fade out the normal perturbation as we move farther from the water surface\\n\\\n    normalTangentSpace.xy *= waveIntensity;\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n#else\\n\\\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 normalEC = enuToEye * normalTangentSpace;\\n\\\n\\n\\\n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\\n\\\n\\n\\\n    // Use diffuse light to highlight the waves\\n\\\n    float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;\\n\\\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\\n\\\n    // the wave bumpiness and no particular light direction.\\n\\\n    float tsPerturbationRatio = normalTangentSpace.z;\\n\\\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\\n\\\n#else\\n\\\n    vec3 nonDiffuseHighlight = vec3(0.0);\\n\\\n#endif\\n\\\n\\n\\\n    // Add specular highlights in 3D, and in all modes when zoomed in.\\n\\\n    float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);\\n\\\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);\\n\\\n    float specular = specularIntensity * surfaceReflectance;\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    specular *= 1.4;\\n\\\n\\n\\\n    float e = 0.2;\\n\\\n    float d = 3.3;\\n\\\n    float c = 1.7;\\n\\\n\\n\\\n    vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));\\n\\\n#else\\n\\\n    vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;\\n\\\n#endif\\n\\\n\\n\\\n    return vec4(color, imageryColor.a);\\n\\\n}\\n\\\n\\n\\\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\";\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"node_modules/cesium/Source/Shaders/GlobeFS.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":15},"source":"node_modules/cesium/Source/Shaders/GlobeFS.js","original":{"line":2,"column":15}}],"sources":{"node_modules/cesium/Source/Shaders/GlobeFS.js":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform vec4 u_initialColor;\\n\\\n\\n\\\n#if TEXTURE_UNITS > 0\\n\\\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\\n\\\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\\n\\\nuniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];\\n\\\n\\n\\\n#ifdef APPLY_ALPHA\\n\\\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_DAY_NIGHT_ALPHA\\n\\\nuniform float u_dayTextureNightAlpha[TEXTURE_UNITS];\\n\\\nuniform float u_dayTextureDayAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\nuniform float u_dayTextureSplit[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\nuniform float u_dayTextureHue[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_GAMMA\\n\\\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_IMAGERY_CUTOUT\\n\\\nuniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\nuniform vec4 u_colorsToAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\nuniform sampler2D u_waterMask;\\n\\\nuniform vec4 u_waterMaskTranslationAndScale;\\n\\\nuniform float u_zoomedOutOceanSpecularIntensity;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\nuniform sampler2D u_oceanNormalMap;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\nuniform vec2 u_lightingFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\nuniform vec4 u_cartographicLimitRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nuniform vec2 u_nightFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\nuniform highp sampler2D u_clippingPlanes;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\nuniform vec4 u_clippingPlanesEdgeStyle;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\nuniform float u_minimumBrightness;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef COLOR_CORRECT\\n\\\nuniform vec3 u_hsbShift; // Hue, saturation, brightness\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\nuniform vec4 u_fillHighlightColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nuniform vec4 u_frontFaceAlphaByDistance;\\n\\\nuniform vec4 u_backFaceAlphaByDistance;\\n\\\nuniform vec4 u_translucencyRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\nuniform vec4 u_undergroundColor;\\n\\\nuniform vec4 u_undergroundColorAlphaByDistance;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec3 v_positionMC;\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_textureCoordinates;\\n\\\nvarying vec3 v_normalMC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\nvarying float v_height;\\n\\\nvarying float v_slope;\\n\\\nvarying float v_aspect;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nvarying float v_distance;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\nvarying vec3 v_fogRayleighColor;\\n\\\nvarying vec3 v_fogMieColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvarying vec3 v_rayleighColor;\\n\\\nvarying vec3 v_mieColor;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nfloat interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)\\n\\\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\\n\\\n{\\n\\\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nbool inTranslucencyRectangle()\\n\\\n{\\n\\\n    return\\n\\\n        v_textureCoordinates.x > u_translucencyRectangle.x &&\\n\\\n        v_textureCoordinates.x < u_translucencyRectangle.z &&\\n\\\n        v_textureCoordinates.y > u_translucencyRectangle.y &&\\n\\\n        v_textureCoordinates.y < u_translucencyRectangle.w;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvec4 sampleAndBlend(\\n\\\n    vec4 previousColor,\\n\\\n    sampler2D textureToSample,\\n\\\n    vec2 tileTextureCoordinates,\\n\\\n    vec4 textureCoordinateRectangle,\\n\\\n    vec4 textureCoordinateTranslationAndScale,\\n\\\n    float textureAlpha,\\n\\\n    float textureNightAlpha,\\n\\\n    float textureDayAlpha,\\n\\\n    float textureBrightness,\\n\\\n    float textureContrast,\\n\\\n    float textureHue,\\n\\\n    float textureSaturation,\\n\\\n    float textureOneOverGamma,\\n\\\n    float split,\\n\\\n    vec4 colorToAlpha,\\n\\\n    float nightBlend)\\n\\\n{\\n\\\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\\n\\\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\\n\\\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\\n\\\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\\n\\\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\\n\\\n    // In other words, the alpha is zero if the fragment is outside the rectangle\\n\\\n    // covered by this texture.  Would an actual 'if' yield better performance?\\n\\\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);\\n\\\n#endif\\n\\\n\\n\\\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\\n\\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\n\\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\n\\\n    vec4 value = texture2D(textureToSample, textureCoordinates);\\n\\\n    vec3 color = value.rgb;\\n\\\n    float alpha = value.a;\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\n    vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);\\n\\\n    colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b);\\n\\\n    alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);\\n\\\n#endif\\n\\\n\\n\\\n#if !defined(APPLY_GAMMA)\\n\\\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\\n\\\n    color = tempColor.rgb;\\n\\\n    alpha = tempColor.a;\\n\\\n#else\\n\\\n    color = pow(color, vec3(textureOneOverGamma));\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\n    float splitPosition = czm_imagerySplitPosition;\\n\\\n    // Split to the left\\n\\\n    if (split < 0.0 && gl_FragCoord.x > splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n    // Split to the right\\n\\\n    else if (split > 0.0 && gl_FragCoord.x < splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\n    color = mix(vec3(0.0), color, textureBrightness);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\n    color = mix(vec3(0.5), color, textureContrast);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\n    color = czm_hue(color, textureHue);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\n    color = czm_saturation(color, textureSaturation);\\n\\\n#endif\\n\\\n\\n\\\n    float sourceAlpha = alpha * textureAlpha;\\n\\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\n\\\n    outAlpha += sign(outAlpha) - 1.0;\\n\\\n\\n\\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\n\\\n\\n\\\n    // When rendering imagery for a tile in multiple passes,\\n\\\n    // some GPU/WebGL implementation combinations will not blend fragments in\\n\\\n    // additional passes correctly if their computation includes an unmasked\\n\\\n    // divide-by-zero operation,\\n\\\n    // even if it's not in the output or if the output has alpha zero.\\n\\\n    //\\n\\\n    // For example, without sanitization for outAlpha,\\n\\\n    // this renders without artifacts:\\n\\\n    //   if (outAlpha == 0.0) { outColor = vec3(0.0); }\\n\\\n    //\\n\\\n    // but using czm_branchFreeTernary will cause portions of the tile that are\\n\\\n    // alpha-zero in the additional pass to render as black instead of blending\\n\\\n    // with the previous pass:\\n\\\n    //   outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor);\\n\\\n    //\\n\\\n    // So instead, sanitize against divide-by-zero,\\n\\\n    // store this state on the sign of outAlpha, and correct on return.\\n\\\n\\n\\\n    return vec4(outColor, max(outAlpha, 0.0));\\n\\\n}\\n\\\n\\n\\\nvec3 colorCorrect(vec3 rgb) {\\n\\\n#ifdef COLOR_CORRECT\\n\\\n    // Convert rgb color to hsb\\n\\\n    vec3 hsb = czm_RGBToHSB(rgb);\\n\\\n    // Perform hsb shift\\n\\\n    hsb.x += u_hsbShift.x; // hue\\n\\\n    hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0); // saturation\\n\\\n    hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0; // brightness\\n\\\n    // Convert shifted hsb back to rgb\\n\\\n    rgb = czm_HSBToRGB(hsb);\\n\\\n#endif\\n\\\n    return rgb;\\n\\\n}\\n\\\n\\n\\\nvec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist);\\n\\\n#endif\\n\\\n\\n\\\nconst float fExposure = 2.0;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\n    if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||\\n\\\n        v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)\\n\\\n        {\\n\\\n            discard;\\n\\\n        }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)\\n\\\n    vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));   // normalized surface normal in model coordinates\\n\\\n    vec3 normalEC = czm_normal3D * normalMC;                                         // normalized surface normal in eye coordiantes\\n\\\n#endif\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);\\n\\\n#else\\n\\\n    float nightBlend = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\\n\\\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\\n\\\n    // fragments on the edges of tiles even though the vertex shader is outputting\\n\\\n    // coordinates strictly in the 0-1 range.\\n\\\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);\\n\\\n\\n\\\n#ifdef SHOW_TILE_BOUNDARIES\\n\\\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\\n\\\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\\n\\\n    {\\n\\\n        color = vec4(1.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\n    float cameraDist;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;\\n\\\n    }\\n\\\n    else if (czm_sceneMode == czm_sceneModeColumbusView)\\n\\\n    {\\n\\\n        cameraDist = -czm_view[3].z;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        cameraDist = length(czm_view[3]);\\n\\\n    }\\n\\\n    float fadeOutDist = u_lightingFadeDistance.x;\\n\\\n    float fadeInDist = u_lightingFadeDistance.y;\\n\\\n    if (czm_sceneMode != czm_sceneMode3D) {\\n\\\n        vec3 radii = czm_ellipsoidRadii;\\n\\\n        float maxRadii = max(radii.x, max(radii.y, radii.z));\\n\\\n        fadeOutDist -= maxRadii;\\n\\\n        fadeInDist -= maxRadii;\\n\\\n    }\\n\\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n#else\\n\\\n    float fade = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\\n\\\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\\n\\\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;\\n\\\n    waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;\\n\\\n\\n\\\n    float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;\\n\\\n\\n\\\n    if (mask > 0.0)\\n\\\n    {\\n\\\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\\n\\\n\\n\\\n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);\\n\\\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);\\n\\\n\\n\\\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\\n\\\n\\n\\\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.st = v_textureCoordinates.st;\\n\\\n    materialInput.normalEC = normalize(v_normalEC);\\n\\\n    materialInput.positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));     \\n\\\n    materialInput.slope = v_slope;\\n\\\n    materialInput.height = v_height;\\n\\\n    materialInput.aspect = v_aspect;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    vec4 materialColor = vec4(material.diffuse, material.alpha);\\n\\\n    color = alphaBlend(materialColor, color);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * 0.9 + 0.3, 0.0, 1.0);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#elif defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\n\\\n    diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#else\\n\\\n    vec4 finalColor = color;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\\n\\\n\\n\\\n    if (clipDistance < clippingPlanesEdgeWidth)\\n\\\n    {\\n\\\n        finalColor = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\n    finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\n    vec3 fogColor = colorCorrect(v_fogMieColor) + finalColor.rgb * colorCorrect(v_fogRayleighColor);\\n\\\n#ifndef HDR\\n\\\n    fogColor = vec3(1.0) - exp(-fExposure * fogColor);\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)\\n\\\n    vec3 atmosphereLightDirection = czm_sunDirectionWC;\\n\\\n#else\\n\\\n    vec3 atmosphereLightDirection = czm_lightDirectionWC;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef FOG\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n    float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);\\n\\\n    fogColor *= darken;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    const float modifier = 0.15;\\n\\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor, modifier), finalColor.a);\\n\\\n#else\\n\\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor), finalColor.a);\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\n    if (!czm_backFacing())\\n\\\n    {\\n\\\n        vec3 groundAtmosphereColor = computeGroundAtmosphereColor(fogColor, finalColor, atmosphereLightDirection, cameraDist);\\n\\\n        finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\n    if (czm_backFacing())\\n\\\n    {\\n\\\n        float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);\\n\\\n        float distance = max(v_distance - distanceFromEllipsoid, 0.0);\\n\\\n        float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);\\n\\\n        vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);\\n\\\n        finalColor = alphaBlend(undergroundColor, finalColor);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\n    if (inTranslucencyRectangle())\\n\\\n    {\\n\\\n      vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;\\n\\\n      finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragColor = finalColor;\\n\\\n}\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist)\\n\\\n{\\n\\\n#if defined(PER_FRAGMENT_GROUND_ATMOSPHERE) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))\\n\\\n    float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);\\n\\\n    vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);\\n\\\n    xy *= czm_viewport.zw * mpp * 0.5;\\n\\\n\\n\\\n    vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x));\\n\\\n    czm_ray ray = czm_ray(vec3(0.0), direction);\\n\\\n\\n\\\n    vec3 ellipsoid_center = czm_view[3].xyz;\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\\n\\\n\\n\\\n    vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);\\n\\\n    ellipsoidPosition = (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;\\n\\\n    AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(ellipsoidPosition, true, atmosphereLightDirection);\\n\\\n\\n\\\n    vec3 groundAtmosphereColor = colorCorrect(atmosColor.mie) + finalColor.rgb * colorCorrect(atmosColor.rayleigh);\\n\\\n#ifndef HDR\\n\\\n    groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\n\\\n#endif\\n\\\n\\n\\\n    float fadeInDist = u_nightFadeDistance.x;\\n\\\n    float fadeOutDist = u_nightFadeDistance.y;\\n\\\n\\n\\\n    float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    // Some tweaking to make HDR look better\\n\\\n    sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\n\\\n#endif\\n\\\n\\n\\\n    groundAtmosphereColor = mix(groundAtmosphereColor, fogColor, sunlitAtmosphereIntensity);\\n\\\n#else\\n\\\n    vec3 groundAtmosphereColor = fogColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    // Some tweaking to make HDR look better\\n\\\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\n\\\n#endif\\n\\\n\\n\\\n    return groundAtmosphereColor;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\\n\\\nfloat waveFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n    return pow(1.0 - y, 5.0);\\n\\\n}\\n\\\n\\n\\\nfloat linearFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Based on water rendering by Jonas Wagner:\\n\\\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\\n\\\n\\n\\\n// low altitude wave settings\\n\\\nconst float oceanFrequencyLowAltitude = 825000.0;\\n\\\nconst float oceanAnimationSpeedLowAltitude = 0.004;\\n\\\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\\n\\\nconst float oceanSpecularIntensity = 0.5;\\n\\\n\\n\\\n// high altitude wave settings\\n\\\nconst float oceanFrequencyHighAltitude = 125000.0;\\n\\\nconst float oceanAnimationSpeedHighAltitude = 0.008;\\n\\\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\\n\\\n\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -positionEyeCoordinates;\\n\\\n    float positionToEyeECLength = length(positionToEyeEC);\\n\\\n\\n\\\n    // The double normalize below works around a bug in Firefox on Android devices.\\n\\\n    vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));\\n\\\n\\n\\\n    // Fade out the waves as the camera moves far from the surface.\\n\\\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // high altitude waves\\n\\\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\\n\\\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\\n\\\n\\n\\\n    // low altitude waves\\n\\\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\\n\\\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\\n\\\n\\n\\\n    // blend the 2 wave layers based on distance to surface\\n\\\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\\n\\\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\\n\\\n    vec3 normalTangentSpace =\\n\\\n        (highAltitudeFade * normalTangentSpaceHighAltitude) +\\n\\\n        (lowAltitudeFade * normalTangentSpaceLowAltitude);\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n\\n\\\n    // fade out the normal perturbation as we move farther from the water surface\\n\\\n    normalTangentSpace.xy *= waveIntensity;\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n#else\\n\\\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 normalEC = enuToEye * normalTangentSpace;\\n\\\n\\n\\\n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\\n\\\n\\n\\\n    // Use diffuse light to highlight the waves\\n\\\n    float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;\\n\\\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\\n\\\n    // the wave bumpiness and no particular light direction.\\n\\\n    float tsPerturbationRatio = normalTangentSpace.z;\\n\\\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\\n\\\n#else\\n\\\n    vec3 nonDiffuseHighlight = vec3(0.0);\\n\\\n#endif\\n\\\n\\n\\\n    // Add specular highlights in 3D, and in all modes when zoomed in.\\n\\\n    float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);\\n\\\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);\\n\\\n    float specular = specularIntensity * surfaceReflectance;\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    specular *= 1.4;\\n\\\n\\n\\\n    float e = 0.2;\\n\\\n    float d = 3.3;\\n\\\n    float c = 1.7;\\n\\\n\\n\\\n    vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));\\n\\\n#else\\n\\\n    vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;\\n\\\n#endif\\n\\\n\\n\\\n    return vec4(color, imageryColor.a);\\n\\\n}\\n\\\n\\n\\\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\";\n"},"lineCount":null}},"error":null,"hash":"f4987fb8d7f3c83b7f394e5e424e6630","cacheData":{"env":{}}}