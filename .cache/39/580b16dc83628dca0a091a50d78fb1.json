{"id":"node_modules/cesium/Source/Shaders/PostProcessStages/LensFlare.js","dependencies":[{"name":"D:\\Users\\Will\\Documents\\CUNY\\Research\\FragMapper\\package.json","includedInParent":true,"mtime":1640105766009},{"name":"D:\\Users\\Will\\Documents\\CUNY\\Research\\FragMapper\\node_modules\\cesium\\package.json","includedInParent":true,"mtime":1640105765416}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n//This file is automatically rebuilt by the Cesium build process.\nvar _default = \"uniform sampler2D colorTexture;\\n\\\nuniform sampler2D dirtTexture;\\n\\\nuniform sampler2D starTexture;\\n\\\nuniform vec2 dirtTextureDimensions;\\n\\\nuniform float distortion;\\n\\\nuniform float ghostDispersal;\\n\\\nuniform float haloWidth;\\n\\\nuniform float dirtAmount;\\n\\\nuniform float earthRadius;\\n\\\nuniform float intensity;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n// whether it is in space or not\\n\\\n// 6500000.0 is empirical value\\n\\\n#define DISTANCE_TO_SPACE 6500000.0\\n\\\n\\n\\\n// return ndc from world coordinate biased earthRadius\\n\\\nvec4 getNDCFromWC(vec3 WC, float earthRadius)\\n\\\n{\\n\\\n    vec4 positionEC = czm_view * vec4(WC, 1.0);\\n\\\n    positionEC = vec4(positionEC.x + earthRadius, positionEC.y, positionEC.z, 1.0);\\n\\\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\\n\\\n    return czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Check if current pixel is included Earth\\n\\\n// if then mask it gradually\\n\\\nfloat isInEarth(vec2 texcoord, vec2 sceneSize)\\n\\\n{\\n\\\n    vec2 NDC = texcoord * 2.0 - 1.0;\\n\\\n    vec4 earthPosSC = getNDCFromWC(vec3(0.0), 0.0);\\n\\\n    vec4 earthPosSCEdge = getNDCFromWC(vec3(0.0), earthRadius * 1.5);\\n\\\n    NDC.xy -= earthPosSC.xy;\\n\\\n\\n\\\n    float X = abs(NDC.x) * sceneSize.x;\\n\\\n    float Y = abs(NDC.y) * sceneSize.y;\\n\\\n\\n\\\n    return clamp(0.0, 1.0, max(sqrt(X * X + Y * Y) / max(abs(earthPosSCEdge.x * sceneSize.x), 1.0) - 0.8 , 0.0));\\n\\\n}\\n\\\n\\n\\\n// For Chromatic effect\\n\\\nvec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion, bool isSpace)\\n\\\n{\\n\\\n    vec2 sceneSize = czm_viewport.zw;\\n\\\n    vec3 color;\\n\\\n    if(isSpace)\\n\\\n    {\\n\\\n        color.r = isInEarth(texcoord + direction * distortion.r, sceneSize) * texture2D(tex, texcoord + direction * distortion.r).r;\\n\\\n        color.g = isInEarth(texcoord + direction * distortion.g, sceneSize) * texture2D(tex, texcoord + direction * distortion.g).g;\\n\\\n        color.b = isInEarth(texcoord + direction * distortion.b, sceneSize) * texture2D(tex, texcoord + direction * distortion.b).b;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        color.r = texture2D(tex, texcoord + direction * distortion.r).r;\\n\\\n        color.g = texture2D(tex, texcoord + direction * distortion.g).g;\\n\\\n        color.b = texture2D(tex, texcoord + direction * distortion.b).b;\\n\\\n    }\\n\\\n    return vec4(clamp(color, 0.0, 1.0), 0.0);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 originalColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 rgb = originalColor.rgb;\\n\\\n    bool isSpace = length(czm_viewerPositionWC.xyz) > DISTANCE_TO_SPACE;\\n\\\n\\n\\\n    // Sun position\\n\\\n    vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0);\\n\\\n    vec4 sunPositionEC = czm_view * sunPos;\\n\\\n    vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC);\\n\\\n    sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0);\\n\\\n\\n\\\n    // If sun is not in the screen space, use original color.\\n\\\n    if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1)))\\n\\\n    {\\n\\\n        // Lens flare is disabled when not in space until #5932 is fixed.\\n\\\n        //    https://github.com/CesiumGS/cesium/issues/5932\\n\\\n        gl_FragColor = originalColor;\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec2 texcoord = vec2(1.0) - v_textureCoordinates;\\n\\\n    vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;\\n\\\n    vec2 invPixelSize = 1.0 / pixelSize;\\n\\\n    vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion);\\n\\\n\\n\\\n    // ghost vector to image centre:\\n\\\n    vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal;\\n\\\n    vec3 direction = normalize(vec3(ghostVec, 0.0));\\n\\\n\\n\\\n    // sample ghosts:\\n\\\n    vec4 result = vec4(0.0);\\n\\\n    vec4 ghost = vec4(0.0);\\n\\\n    for (int i = 0; i < 4; ++i)\\n\\\n    {\\n\\\n        vec2 offset = fract(texcoord + ghostVec * float(i));\\n\\\n        // Only bright spots from the centre of the source image\\n\\\n        ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace);\\n\\\n    }\\n\\\n    result += ghost;\\n\\\n\\n\\\n    // sample halo\\n\\\n    vec2 haloVec = normalize(ghostVec) * haloWidth;\\n\\\n    float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\\n\\\n    weightForHalo = pow(1.0 - weightForHalo, 5.0);\\n\\\n\\n\\\n    result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec, isSpace) * weightForHalo * 1.5;\\n\\\n\\n\\\n    // dirt on lens\\n\\\n    vec2 dirtTexCoords = (v_textureCoordinates * invPixelSize) / dirtTextureDimensions;\\n\\\n    if (dirtTexCoords.x > 1.0)\\n\\\n    {\\n\\\n        dirtTexCoords.x = mod(floor(dirtTexCoords.x), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.x) :  fract(dirtTexCoords.x);\\n\\\n    }\\n\\\n    if (dirtTexCoords.y > 1.0)\\n\\\n    {\\n\\\n        dirtTexCoords.y = mod(floor(dirtTexCoords.y), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.y) :  fract(dirtTexCoords.y);\\n\\\n    }\\n\\\n    result += dirtAmount * texture2D(dirtTexture, dirtTexCoords);\\n\\\n\\n\\\n    // Rotating starburst texture's coordinate\\n\\\n    // dot(czm_view[0].xyz, vec3(0.0, 0.0, 1.0)) + dot(czm_view[1].xyz, vec3(0.0, 1.0, 0.0))\\n\\\n    float camrot = czm_view[0].z + czm_view[1].y;\\n\\\n    float cosValue = cos(camrot);\\n\\\n    float sinValue = sin(camrot);\\n\\\n    mat3 rotation = mat3(\\n\\\n        cosValue, -sinValue, 0.0,\\n\\\n        sinValue, cosValue, 0.0,\\n\\\n        0.0, 0.0, 1.0\\n\\\n    );\\n\\\n\\n\\\n    vec3 st1 = vec3(v_textureCoordinates * 2.0 - vec2(1.0), 1.0);\\n\\\n    vec3 st2 = vec3((rotation * st1).xy, 1.0);\\n\\\n    vec3 st3 = st2 * 0.5 + vec3(0.5);\\n\\\n    vec2 lensStarTexcoord = st3.xy;\\n\\\n    float weightForLensFlare = length(vec3(sunPos.xy, 0.0));\\n\\\n    float oneMinusWeightForLensFlare = max(1.0 - weightForLensFlare, 0.0);\\n\\\n\\n\\\n    if (!isSpace)\\n\\\n    {\\n\\\n        result *= oneMinusWeightForLensFlare * intensity * 0.2;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        result *= oneMinusWeightForLensFlare * intensity;\\n\\\n        result *= texture2D(starTexture, lensStarTexcoord) * pow(weightForLensFlare, 1.0) * max((1.0 - length(vec3(st1.xy, 0.0))), 0.0) * 2.0;\\n\\\n    }\\n\\\n\\n\\\n    result += texture2D(colorTexture, v_textureCoordinates);\\n\\\n\\n\\\n    gl_FragColor = result;\\n\\\n}\\n\\\n\";\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"node_modules/cesium/Source/Shaders/PostProcessStages/LensFlare.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":15},"source":"node_modules/cesium/Source/Shaders/PostProcessStages/LensFlare.js","original":{"line":2,"column":15}}],"sources":{"node_modules/cesium/Source/Shaders/PostProcessStages/LensFlare.js":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform sampler2D colorTexture;\\n\\\nuniform sampler2D dirtTexture;\\n\\\nuniform sampler2D starTexture;\\n\\\nuniform vec2 dirtTextureDimensions;\\n\\\nuniform float distortion;\\n\\\nuniform float ghostDispersal;\\n\\\nuniform float haloWidth;\\n\\\nuniform float dirtAmount;\\n\\\nuniform float earthRadius;\\n\\\nuniform float intensity;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n// whether it is in space or not\\n\\\n// 6500000.0 is empirical value\\n\\\n#define DISTANCE_TO_SPACE 6500000.0\\n\\\n\\n\\\n// return ndc from world coordinate biased earthRadius\\n\\\nvec4 getNDCFromWC(vec3 WC, float earthRadius)\\n\\\n{\\n\\\n    vec4 positionEC = czm_view * vec4(WC, 1.0);\\n\\\n    positionEC = vec4(positionEC.x + earthRadius, positionEC.y, positionEC.z, 1.0);\\n\\\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\\n\\\n    return czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Check if current pixel is included Earth\\n\\\n// if then mask it gradually\\n\\\nfloat isInEarth(vec2 texcoord, vec2 sceneSize)\\n\\\n{\\n\\\n    vec2 NDC = texcoord * 2.0 - 1.0;\\n\\\n    vec4 earthPosSC = getNDCFromWC(vec3(0.0), 0.0);\\n\\\n    vec4 earthPosSCEdge = getNDCFromWC(vec3(0.0), earthRadius * 1.5);\\n\\\n    NDC.xy -= earthPosSC.xy;\\n\\\n\\n\\\n    float X = abs(NDC.x) * sceneSize.x;\\n\\\n    float Y = abs(NDC.y) * sceneSize.y;\\n\\\n\\n\\\n    return clamp(0.0, 1.0, max(sqrt(X * X + Y * Y) / max(abs(earthPosSCEdge.x * sceneSize.x), 1.0) - 0.8 , 0.0));\\n\\\n}\\n\\\n\\n\\\n// For Chromatic effect\\n\\\nvec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion, bool isSpace)\\n\\\n{\\n\\\n    vec2 sceneSize = czm_viewport.zw;\\n\\\n    vec3 color;\\n\\\n    if(isSpace)\\n\\\n    {\\n\\\n        color.r = isInEarth(texcoord + direction * distortion.r, sceneSize) * texture2D(tex, texcoord + direction * distortion.r).r;\\n\\\n        color.g = isInEarth(texcoord + direction * distortion.g, sceneSize) * texture2D(tex, texcoord + direction * distortion.g).g;\\n\\\n        color.b = isInEarth(texcoord + direction * distortion.b, sceneSize) * texture2D(tex, texcoord + direction * distortion.b).b;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        color.r = texture2D(tex, texcoord + direction * distortion.r).r;\\n\\\n        color.g = texture2D(tex, texcoord + direction * distortion.g).g;\\n\\\n        color.b = texture2D(tex, texcoord + direction * distortion.b).b;\\n\\\n    }\\n\\\n    return vec4(clamp(color, 0.0, 1.0), 0.0);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 originalColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 rgb = originalColor.rgb;\\n\\\n    bool isSpace = length(czm_viewerPositionWC.xyz) > DISTANCE_TO_SPACE;\\n\\\n\\n\\\n    // Sun position\\n\\\n    vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0);\\n\\\n    vec4 sunPositionEC = czm_view * sunPos;\\n\\\n    vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC);\\n\\\n    sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0);\\n\\\n\\n\\\n    // If sun is not in the screen space, use original color.\\n\\\n    if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1)))\\n\\\n    {\\n\\\n        // Lens flare is disabled when not in space until #5932 is fixed.\\n\\\n        //    https://github.com/CesiumGS/cesium/issues/5932\\n\\\n        gl_FragColor = originalColor;\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec2 texcoord = vec2(1.0) - v_textureCoordinates;\\n\\\n    vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;\\n\\\n    vec2 invPixelSize = 1.0 / pixelSize;\\n\\\n    vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion);\\n\\\n\\n\\\n    // ghost vector to image centre:\\n\\\n    vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal;\\n\\\n    vec3 direction = normalize(vec3(ghostVec, 0.0));\\n\\\n\\n\\\n    // sample ghosts:\\n\\\n    vec4 result = vec4(0.0);\\n\\\n    vec4 ghost = vec4(0.0);\\n\\\n    for (int i = 0; i < 4; ++i)\\n\\\n    {\\n\\\n        vec2 offset = fract(texcoord + ghostVec * float(i));\\n\\\n        // Only bright spots from the centre of the source image\\n\\\n        ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace);\\n\\\n    }\\n\\\n    result += ghost;\\n\\\n\\n\\\n    // sample halo\\n\\\n    vec2 haloVec = normalize(ghostVec) * haloWidth;\\n\\\n    float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\\n\\\n    weightForHalo = pow(1.0 - weightForHalo, 5.0);\\n\\\n\\n\\\n    result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec, isSpace) * weightForHalo * 1.5;\\n\\\n\\n\\\n    // dirt on lens\\n\\\n    vec2 dirtTexCoords = (v_textureCoordinates * invPixelSize) / dirtTextureDimensions;\\n\\\n    if (dirtTexCoords.x > 1.0)\\n\\\n    {\\n\\\n        dirtTexCoords.x = mod(floor(dirtTexCoords.x), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.x) :  fract(dirtTexCoords.x);\\n\\\n    }\\n\\\n    if (dirtTexCoords.y > 1.0)\\n\\\n    {\\n\\\n        dirtTexCoords.y = mod(floor(dirtTexCoords.y), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.y) :  fract(dirtTexCoords.y);\\n\\\n    }\\n\\\n    result += dirtAmount * texture2D(dirtTexture, dirtTexCoords);\\n\\\n\\n\\\n    // Rotating starburst texture's coordinate\\n\\\n    // dot(czm_view[0].xyz, vec3(0.0, 0.0, 1.0)) + dot(czm_view[1].xyz, vec3(0.0, 1.0, 0.0))\\n\\\n    float camrot = czm_view[0].z + czm_view[1].y;\\n\\\n    float cosValue = cos(camrot);\\n\\\n    float sinValue = sin(camrot);\\n\\\n    mat3 rotation = mat3(\\n\\\n        cosValue, -sinValue, 0.0,\\n\\\n        sinValue, cosValue, 0.0,\\n\\\n        0.0, 0.0, 1.0\\n\\\n    );\\n\\\n\\n\\\n    vec3 st1 = vec3(v_textureCoordinates * 2.0 - vec2(1.0), 1.0);\\n\\\n    vec3 st2 = vec3((rotation * st1).xy, 1.0);\\n\\\n    vec3 st3 = st2 * 0.5 + vec3(0.5);\\n\\\n    vec2 lensStarTexcoord = st3.xy;\\n\\\n    float weightForLensFlare = length(vec3(sunPos.xy, 0.0));\\n\\\n    float oneMinusWeightForLensFlare = max(1.0 - weightForLensFlare, 0.0);\\n\\\n\\n\\\n    if (!isSpace)\\n\\\n    {\\n\\\n        result *= oneMinusWeightForLensFlare * intensity * 0.2;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        result *= oneMinusWeightForLensFlare * intensity;\\n\\\n        result *= texture2D(starTexture, lensStarTexcoord) * pow(weightForLensFlare, 1.0) * max((1.0 - length(vec3(st1.xy, 0.0))), 0.0) * 2.0;\\n\\\n    }\\n\\\n\\n\\\n    result += texture2D(colorTexture, v_textureCoordinates);\\n\\\n\\n\\\n    gl_FragColor = result;\\n\\\n}\\n\\\n\";\n"},"lineCount":null}},"error":null,"hash":"ef1b3cfb3e6b34a327eedba31a407c1e","cacheData":{"env":{}}}